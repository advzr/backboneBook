Итак, я твердо решил написать хорошую книгу по Backbone.js. Делать это я буду в свободное время, поэтому возможно новые главы будут появляться не так часто как хотелось бы. Тем более, что я хочу написать хорошую книгу. А это значит, что главным приоритетом для меня будет не скорость, а качество. Также, я не исключаю, что буду возвращаться к предыдущим главам для их улучшения. Поэтому вполне возможно, что прочитав ее раз, через некоторое время мы сможете обнаружить для себя в ней что-то новое. Этим и замечательна online публикация. О всех важных изменениях буду публиковать сообщения в блоге. Поэтому подписывайтесь на <a title="RSS рассылка" href="http://?feed=rss2">RSS</a> и следите за обновлениями. Очень надеюсь, что данная книга окажется для вас полезной.

С уважением
Дмитрий Гавриков

<h2>Для кого эта книга?</h2>
Эта книга для начинающих знакомиться с Backbone.js. Более того, основная ее цель - сделать это знакомство как можно более приятным и быстрым, чтобы вы были в состоянии в дальнейшем самостоятельно использовать этот фреймворк для своих целей. Однако, данная книга не является книгой для начинающих в Javascript. Предполагается, что читатель уже обладает следующими знаниями:
<ul>
	<li>знания чистого Javascript</li>
	<li>понимание принципов ООП</li>
	<li>манипуляции с DOM и обработка событий с помощью jQuery</li>
	<li>шаблонизация с использованием Underscore/Lodash</li>
	<li>организация кода при помощи Require.js (в более поздних главах)</li>
</ul>
Если что-то из этого списка для вас является непонятным, то рекоммендую перед дальнейшим чтением восполнить эти пробелы, чтобы получить максимальную пользу от книги.

<h2>Зачем нужен Backbone.js</h2>
И так. Зачем же все-таки нужно использовать фреймворки подобные Backbone.js?

Наверняка вы сталкивались с кодом, который напоминает миску со спатетти. Большое количество вложенных if конструкций, функции хаотично разбросанные по всему коду, и вызываемые отовсюду, или же такая куча функций, вложенных друг в друга, что, когда доберешься до последней, забываешь что собственно делали все предыдущие, и зачем вообще было надо заглядывать в первую. Да, это настоящий кошмар разработчика.

Вообще разбираться в чужом коде бывает не просто только потому, что он чужой, а вовсе не обязательно, потому что это спагетти-код. А если он такой, как описано выше, то легче <del>застрелиться</del> переписать все с нуля, чем править подобный код. Ведь текущая правка наверняка будет не единственной, а значит этот кошмар не закончится, а будет вас преследовать постоянно.

Однако, это довольно маргинальный случай. Рассмотрим более реалистичный сценарий. Вы пишете свой собственный код, вам не дышит менеджер в затылок, вы применяете ООП, грамотно выделяя сущности в классы, тщательно выбираете имена переменным и функциям и используете систему собственных событий для связи классов между собой. Значит ли это, что Backbone окажется для вас лишним? Не станет ли он просто дополнительной бесполезной нагрузкой или, что еще хуже, не будет ли он мешать? Вовсе нет.

Даже в такой, казалось бы близкой к идеальной, ситуации вам как разработчику придется решать много однотипных вопросов. Какой тип данных использовать для доступа к серверу через Ajax? Сразу тянуть готовый HTML или взять JSON, а уже на стороне клиента самому генерировать HTML? Как организовать код для генерации HTML и вставки его в DOM? По-быстрому добавить строчку jQuery прямо в функции с логикой или же выделить его в отдельную функцию render? А может создать для этого целый отдельный класс Render? А если нам необходимо отображать информацию по-разному в зависимости от абстоятельств, то нам надо их все учитывать прямо в функции render/классе Render или же в каждом случае создавать отдельные функции/классы, отвечающие за отображение? Как осуществлять связь между классами? Экземпляры классов будут создавать собственные события, а "слушающие" их будут на них реагировать, или же лучше напрямую обращаться к методам класса? И это не полный перечень подобных вопросов.

Вы можете сказать, что ответы на эти вопросы будут разными в зависимости от абстоятельств, от того куда будет код двигаться дальше. Нужно выбирать минимально сложное решение, чтобы оно было достаточным в конкретной ситуации, дабы не плодить лишних сущностей. Если нам важно просто вставить HTML в страницу и не нужно будет в дальнейшем эти данные как-то использовать, то наверное проще вытянуть с сервера готовый HTML, а тянуть JSON и генерировать HTML с помощью шаблона будет перебором. И т.д.

Все верно. Однако, представим себе такой проект в котором допустим штук 20 уникальных взаимосвязанных элементов интерфейса. Не независимых, а именно взаимосвязанных. Т.е. когда пользователь чего-то ткнул/написал в одном месте, в нескольких других произошли соответствующие изменения. Каждому типу элемента соответствует свой класс, и в каждом случае мы отвечали на вышестоящие вопросы по-разному в зависимости от абстоятельств.

Представили? Отлично. Теперь вы понимаете, каково это каждый раз заходить в отдельный класс, искать, каким образом он взаимодействует с сервером, где и каким образом хранится состояние класса, в каком месте прописано отображение класса в браузере, что за события он использует, и какие генерирует сам. А если таких уникальных элементов не 20, а 50? А если 100 или больше? Не знаю как у вас, а у меня от таких мыслей начинает зеленеть цвет лица.

Так, а что же тогда делать? Использовать общую конвенцию, по которой все классы устроены одинаковым образом? Но тогда нам придется всегда использовать максимально сложный вариант. Т.е. связь с сервером только в JSON, генерация HTML только на клиенте, даже если он состоит во вставке однострочного &lt;li&gt;, для каждого способа отображения отдельная функция или даже класс, связь между классами с помощью унифицированных событий и т.д. Да, все именно так.

Подождите, но это же целая куча дополнительной и, к тому же, рутинной работы. Все верно, но только отчасти. Сложность заключается в написании первоначальных классов. Потом, благодаря идентичной архитектуре, можно смело заниматься копипастом, изменяя только уникальные части классов.

Копипастом? Шучу. Заниматься копипастом - глупо и рутинно. Поэтому мы будем использовать наследование. И если в этот момент у вас возникла мысль, а нет ли какого-либо готового инструмента для всего этого, чтобы не создавать свой двухколесный транспорт на мышечной тяге, то могу вас порадовать, что он есть, и имя ему Backbone.js.

В последующих главах мы разберем, из чего он состоит, и как эти части использовать на примере создания простого списка дел.

<h2>Модели</h2>
Объяснять составные части Backbone.js отдельно друг от друга довольно сложно по причине их высокой взаимосвязи. Поэтому, если ранее вы не имели дело с MV* шаблонами проектирования, то поначалу у вас может возникнуть легкое непонимание "зачем это все надо, и как это можно использовать". Это нормально. Наберитесь терпения, и довольно скоро мозаика начнет складываться. Итак, приступим.
<h3>Рабочая заготовка</h3>
Для начала определимся с рабочим файлом, в котором будем писать весь код. Так как примеры являются учебными, то будем использовать самый простой вариант:

[php]<!DOCTYPE HTML>
<html>
  
  <head>
    <style>
      // Здесь будет CSS код, если понадобится
    </style>
    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.5.2/underscore-min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.1.0/backbone-min.js"></script>
  </head>
  
  <body>
    <!-- Здесь будут располагаться DOM элементы -->
    <script>
      // Здесь мы будем писать наш Javascript
    </script>
  </body>

</html>[/php]


<em>Примечание: Для экономии места и времени в дальнейшем целиком файл показываться не будет, а будут отдельные куски Javascript, HTML или CSS кода, что подразумевает, что их необходимо вставить в соответствующее место в файле.</em> 

<h3>Организация данных</h3>

Что же такое модель в Backbone.js? Если коротко, то это объект с данными. Не html элементы, а данные в чистом виде. Предположим, что мы создаем нумерованный список объявлений о продаже автомобилей. Что вы себе представляете? Если представили что-то вроде
[php]<ol>
	<li>данные</li>
	<li>данные</li>
	<li>данные</li>
</ol>[/php]

то это не данные, а их отображение. Забегая вперед, скажу, что в MV*, и в Backbone в частности, это называется вид. А модель это сами данные, которые вставляются в html код. Какие это могут быть данные? Ну например это может быть марка и модель продаваемого автомобиля, год его выпуска, пробег, цена и т.д.

Зачем нам нужны эти данные отдельно от html? Они нужны для удобного доступа к ним, если вдруг нам захочется их поменять или использовать где-то еще. Допустим нам захочется, чтобы список умел сортировать сам себя по цене при нажатии на определенную кнопку. Если бы у нас не было данных отдельно, то пришлось бы цену как-то выделять из html. А это неудобно и грозит трудноуловимыми ошибками.

Теоритически данные можно хранить и в примитивах, но лучше всего для этого подходит объект, так как все данные находятся в одном месте.

Сперва посмотрим как данные можно хранить на примере чистого Javascript.

[js]var Advertisement = function(opts) {
  this.make = opts.make;
  this.model = opts.model;
  this.year = opts.year;
  this.price = opts.price;
};[/js]

А теперь представим, что это у нас не совсем доска объявлений, а, допустим, список лотов на аукционе в Японии. По такой причине цены на автомобили логичнее хранить в ценах продавца, т.е. в японских иенах. Однако покупателям удобнее видеть цены в рублях, а иены, если и показывать, то справочно. В таком случае нам нужна функция, которая бы конвертировала иены в рубли. Куда ее записать? В класс Advertisement? Вполне возможно, но в таком случае каждый экземпляр класса будет содержать свой собственный экземпляр функции, что не очень экономично, особенно, если экземпляров класса будет много. Правильнее использовать наследование и записать функцию в прототип.

[js]Advertisement.prototype.getPriceInRUB = function(rate) {
  return this.price * rate;
};[/js]

Теперь будет достаточно запросить текущий курс иены к рублю, и экземпляр класса легко сможет сам нам сказать свою цену в рублях.

[js]var Advertisement = function(opts) {
  this.make = opts.make;
  this.model = opts.model;
  this.year = opts.year;
  this.price = opts.price;
};

Advertisement.prototype.getPriceInRUB = function(rate) {
  return this.price * rate;
};

var ad = new Advertisement({
  make: 'Mazda',
  model: 'Atenza',
  year: 2007,
  price: 1700000
});

var RUBJPY = 0.32; // курс рубля к иене, который мы заранее получили от сервера

alert(ad.getPriceInRUB(RUBJPY)); // 544 000 руб.[/js]
<h3>Модель в Backbone.js</h3>
После того как мы рассмотрели пример организации данных в чистом Javascript, самое время посмотреть, как реализовать подобное средствами Backbone.js.

Данные в программах, написанных с использованием Backbone.js, хранятся в моделях - конструкторах объектов с уже готовым набором дополнительных служебных функций. Создаются модели путем расширения базовой модели, прописанной в Backbone.js.

[js]var Model = Backbone.Model.extend();[/js]

Таким образом, мы создали новый конструктор (или класс) Model, который в данном конкретном случае ничем не отличается от базового класса модели, так как мы его ни чем не расширили. Для этого необходимо передать функции extend объект с дополнительными параметрами. Если вернемся к нашим объявлениям, модель могла бы быть описана вот так.

[js]var Advertisement = Backbone.Model.extend({
  defaults: {
    make: 'Тойота',
    model: 'Королла',
    year: 2010,
    price: 2000000
  },
  getPriceInRUB: function(rate) {
    return this.get('price') * rate;
  }
});[/js]
<h3>Доступ к атрибутам модели</h3>
Если посмотрим на код выше, то станет ясно, что появился новый объект, который мы записали в свойство defaults. Как видно из названия, это данные, которые будут у экземпляра класса по умолчанию. Согласен, глупо передавать по умолчанию данные какого-то конкретного объявления. Но применительно к нашему примеру трудно представить вообще какие-то осмысленные значения по умолчанию. В реальном приложении скорее всего их бы не было вовсе. Но здесь они просто ради образовательной цели, чтобы вы знали, что возможность задавать значения по умолчанию есть.

<em>Чтобы хоть как-то оправдать их наличие в данном примере, представим, что их сюда прописал разработчик для отладки. Ему нужно будет создать несколько экземпляров класса, чтобы посмотреть их в работе. И ему лень присваивать каждому экземпляру индивидуальные данные. Ведь ему важно посмотреть работу класса, а какие в них будут данные для него не важно. Впрочем как и для нас.</em>

Перейдем к функции <code>getPriceInRUB</code>. Как видим, <code>this.price</code> превратилось в <code>this.get('price')</code>. Это произошло потому, что данные в модели не хранятся напрямую в свойствах объекта, а находятся в виде объекта в свойстве <code>attributes</code>. Т.е. мы вполне могли написать <code>this.attributes.price</code>, но так лучше не делать, а пользоваться встроенной функцией <code>get</code>. Во-первых, это короче. А во-вторых, модель способна самостоятельно отслеживать изменения своих данных. Как вы наверняка догадались, если есть <code>get</code>, то должна быть и <code>set</code>. Так вот при вызове <code>set</code> модель создает событие <code>change</code>, с помощью которого очень удобно отслеживать изменения в модели. Если бы мы изменили свойство напрямую, то событие бы не создалось. Но об этом чуть позже.

Теперь когда мы описали класс, самое время создать экземпляр этого класса. Создается он стандартным способом при помощи <code>new</code>, при этом конструктору передается объект с данными, которые попадут в экземпляр класса.

[js]var ad = new Advertisement({
  make: 'Mazda',
  model: 'Atenza',
  year: 2007,
  price: 1700000
});

alert(ad.get('make')); // Mazda[/js]

Мы рассмотрели, как передать данные при создании экземпляра модели. Но нам ничего не мешало сперва создать экземпляр модели, а уже после этого передать в него данные. В этом нам поможет функция <code>set</code>. Эта функция принимает либо строку с наименованием изменяемого атрибута и новое значение, либо объект с новыми атрибутами и их значениями. Таким образом, следующие две записи полностью равнозначны.

[js]ad.set('price', 1500000);
ad.set({price: 1500000});[/js]

Как правило первую предпочитают, если необходимо изменить только один атрибут, а вторую - если сразу несколько. Как вы уже узнали, при обращении к функции <code>set</code> создается событие <code>change</code>. При этом событие произойдет только при изменении значения. Т.е. если бы эти две строчки стояли в коде одновременно, то событие <code>change</code> было бы вызвано только один раз, так как во втором случае изменения атрибута не произошло (цена-то одна и та же). В дальнейшем мы найдем более подходящее место для размещения обработчиков, но сейчас нам ничто не помешает навешать его прямо на экземпляр класса. Ведь нам главное посмотреть в работе функцию <code>set</code>.

[js]var ad = new Advertisement({
  make: 'Mazda',
  model: 'Atenza',
  year: 2007,
  price: 1700000
});

ad.on('change', function() {
  alert('Новая цена: ' + this.get('price'));
});

ad.set('price', 1500000); // "Новая цена: 1500000"
ad.set({price: 1500000}); // событие change не будет вызвано
ad.set('price', 1600000); // "Новая цена: 1600000"[/js]

Однако иногда нам может понадобиться возможность поменять значение атрибута "по-тихому". Для этого необходимо передать функции <code>set</code> дополнительный аргумент в виде объекта <em>(его в документации называют options)</em> <code>{silent: true}</code>. В таком случае наши две эквивалентных записи примут следующий вид.

[js]ad.set('price', 1500000, {silent: true});
ad.set({price: 1500000}, {silent: true});[/js]

Чтобы получить все атрибуты модели разом, используется метод <code>toJSON</code>. Применительно к нашему примеру мы могли бы вывести все атрибуты в консоль таким способом.

[js]var attrs = ad.toJSON();
console.log(attrs);[/js]

Несмотря на название, метод <code>toJSON</code> возвращает не JSON строку, а обычный Javascript объект, в свойствах которого записаны атрибуты модели. Такой вот парадокс. Однако, если же вам нужна именно JSON строка, то ее можно получить с помощью функции <code>JSON.stringify</code>, которой передается в качестве аргумента объект Javascript.

[js]var attrs = ad.toJSON();
console.log(JSON.stringify(attrs)); // {"make":"Mazda","model":"Atenza","year":2007,"price":1600000}[/js]
<h3>Валидация значений атрибутов</h3>
Любое ли значение можно присваивать атрибутам? Как вам например производитель автомобилей в виде числа 1000? Да, конечно, когда нас поработят наши компьютеры, определять производителей по некоему id в виде числа станет вполне логичным, но пока этого не произошло, это выглядит несколько странно. А как вам цена в виде числа -5000? Ну это-то уже ни в какие ворота. Однако, вы скажете, что нужно следить за тем, какие значения задаются, и будете правы. Но почему бы не отсечь сразу заведомо неверные варианты? Тем более, что Backbone.js предоставляет для этого простые встроенные средства.

Если при создании класса модели расширить базовую модель Backbone.js свойством <code>validate</code> и передать в него функцию, то первым аргументом ей будет передан объект с атрибутами модели. Тот самый, который мы получали при помощи метода <code>toJSON</code>. Данная функция работает следующим образом. Если она ничего не возврщает, то значит установка атрибута прошла успешно. В таком случае метод <code>set</code> вернет ссылку на экземпляр модели, для которой он был вызван, после смены атрибута. А если функции validate будет указано что-то вернуть, то <code>set</code> вернет <code>false</code>, и изменения значения атрибута не будет. Это очень удобно, поскольку позволяет использовать метод <code>set</code> в конструкции <code>if</code> в качестве условия, так как при удачном изменении параметра метод <code>set</code> вернет объект, что эквивалентно <code>true</code>, а при неудачном - <code>false</code>. Посмотрим на примере, как нам не допустить установления отрицательной цены на наши автомобили.

[js]var Advertisement = Backbone.Model.extend({
  defaults: {
    make: 'Тойота',
    model: 'Королла',
    year: 2010,
    price: 2000000
  },
  validate: function(attrs) {
    if (attrs.price < 0) {
      return 'Цена не может быть отрицательной'
    }
  },
  getPriceInRUB: function(rate) {
    return this.get('price') * rate;
  }
});[/js]

Обратите внимание, что мы возвращаем строку при провалившейся валидации с описанием ошибки. Однако, как ее получить, если метод <code>set</code> в таком случае вернет <code>false</code>, а не эту строку? Это может быть полезно, например, для того, чтобы вывести ее на экране пользователя, который ввел неверное значение. Ее мы можем получить, навешав обработчик на специальное событие. Но прежде чем продолжить, вам необходимо знать, что начиная с версии 1.0.0 в Backbone.js произошли существенные изменения в этом вопросе. Поэтому мы с вами рассмотрим оба варианта, так как возможно вы еще столкнетесь со старым кодом.

До версии 1.0.0
<ol>
	<li>Валидация происходит как при вызове метода <code>save</code> <em>(этот метод сохраняет модель на сервере, о нем мы поговорим в следующих главах)</em>, так и метода <code>set</code></li>
	<li>Генерируется событие <code>error</code></li>
</ol>
После версии 1.0.0
<ol>
	<li>Валидация происходит всегда при вызове метода <code>save</code>, но по умолчанию не происходит при вызове метода <code>set</code>. Чтобы валидация проводилась и при вызове метода <code>set</code>, то необходимо при его вызове передать в объекте <code>options</code> <code>{validate:true}</code> <em>(в том самом, в котором мы передавали <code>{silent: true}</code>)</em></li>
	<li>Вместо события <code>error</code> генерируется событие <code>invalid</code></li>
</ol>
Пример кода для версии до 1.0.0
<em>Примечание: данный код не будет корректно работать в нашем рабочем файле. Если вы хотите посмотреть на его работу, то замените значение версии Backbone.js в атрибуте <code>src</code> с <code>1.1.0</code> на <code>0.9.9</code></em>

[js]var Advertisement = Backbone.Model.extend({
  defaults: {
    make: 'Тойота',
    model: 'Королла',
    year: 2010,
    price: 2000000
  },
  validate: function(attrs) {
    if (attrs.price < 0) {
      return 'Цена не может быть отрицательной';
    }
  },
  getPriceInRUB: function(rate) {
    return this.get('price') * rate;
  }
});

var ad = new Advertisement({
  make: 'Mazda',
  model: 'Atenza',
  year: 2007,
  price: 1700000
});

ad.on('error', function(model, error) {
  alert(error);
});

ad.set('price', -1500000); // "Цена не может быть отрицательной"[/js]

Пример кода для версии после 1.0.0

[js]var Advertisement = Backbone.Model.extend({
  defaults: {
    make: 'Тойота',
    model: 'Королла',
    year: 2010,
    price: 2000000
  },
  validate: function(attrs) {
    if (attrs.price < 0) {
      return 'Цена не может быть отрицательной';
    }
  },
  getPriceInRUB: function(rate) {
    return this.get('price') * rate;
  }
});

var ad = new Advertisement({
  make: 'Mazda',
  model: 'Atenza',
  year: 2007,
  price: 1700000
});

ad.on('invalid', function(model, error) {
  alert(error);
});

ad.set('price', -1500000, {validate:true}); // "Цена не может быть отрицательной"[/js]

Теперь мы можем вывести весь код, который мы использовали в этой главе, целиком. Внимательно прочитайте его и убедитесь, что вам понятно, как он работает. На этом наше знакомство с моделями закончено, и мы переходим к видам.

[js]var Advertisement = Backbone.Model.extend({
  defaults: {
    make: 'Тойота',
    model: 'Королла',
    year: 2010,
    price: 2000000
  },
  validate: function(attrs) {
    if (attrs.price < 0) {
      return 'Цена не может быть отрицательной';
    }
  },
  getPriceInRUB: function(rate) {
    return this.get('price') * rate;
  }
});

var ad = new Advertisement({
  make: 'Mazda',
  model: 'Atenza',
  year: 2007,
  price: 1700000
});

ad.on('invalid', function(model, error) {
  alert(error);
});

ad.on('change', function() {
  alert('Новая цена: ' + this.get('price'));
});

ad.set('price', -1500000, {validate:true}); // "Цена не может быть отрицательной"
ad.set('price', 1500000); // "Новая цена: 1500000"
ad.set({price: 1500000}); // событие change не произойдет
ad.set('price', 1600000, {silent:true}); // цена изменится, но события change не произойдет

var RUBJPY = 0.32; // курс рубля к иене, который мы заранее получили от сервера

alert(ad.getPriceInRUB(RUBJPY)); // 512 000 руб.[/js]
